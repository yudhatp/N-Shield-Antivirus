; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\Yudha Projects\N-Shield AntiVirus\SOURCE\DRIVER\Nshield.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_IoGetCurrentIrpStackLocation@4
PUBLIC	_CreateProcessNotifyRoutineActivated
PUBLIC	??_C@_1CI@LPCKBFKB@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAN?$AAS?$AAH?$AAI?$AAE?$AAL?$AAD?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CA@HCBGJDP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAN?$AAS?$AAH?$AAI?$AAE?$AAL?$AAD?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@MLPIADGK@?$AAZ?$AAw?$AAQ?$AAu?$AAe?$AAr?$AAy?$AAI?$AAn?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AAi?$AAo?$AAn?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$AA@ ; `string'
EXTRN	__imp__KeSetEvent@12:PROC
EXTRN	__imp__PsGetCurrentProcessId@0:PROC
EXTRN	__imp__MmGetSystemRoutineAddress@4:PROC
EXTRN	_PsProcessType:DWORD
EXTRN	__imp__PsLookupProcessByProcessId@8:PROC
EXTRN	__imp__ObOpenObjectByPointer@28:PROC
EXTRN	__imp__KeGetCurrentIrql@0:PROC
EXTRN	__imp__ZwClose@4:PROC
EXTRN	__imp__KeClearEvent@4:PROC
EXTRN	__imp__IoDeleteSymbolicLink@4:PROC
EXTRN	__imp_@ObfDereferenceObject@4:PROC
EXTRN	__imp__RtlInitUnicodeString@8:PROC
EXTRN	__imp__IoCreateDevice@28:PROC
EXTRN	__imp__IoCreateSymbolicLink@8:PROC
EXTRN	__imp__IoDeleteDevice@4:PROC
EXTRN	_memcpy:PROC
EXTRN	_wcsncat:PROC
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
EXTRN	__imp__ExFreePoolWithTag@8:PROC
EXTRN	__imp_@IofCompleteRequest@8:PROC
EXTRN	__imp__ObReferenceObjectByHandle@24:PROC
EXTRN	_ExEventObjectType:DWORD
EXTRN	__imp__PsSetCreateProcessNotifyRoutine@8:PROC
COMM	_HostProcessId:DWORD
COMM	_ProcessMonitorEvent:DWORD
COMM	_ProcessMonitorCallbackInfo:DWORD
COMM	_ZwQueryInformationProcess:DWORD
COMM	___@@_PchSym_@00@UbfwszLkilqvxghUmRhsrvowLzmgrerifhUhlfixvUwireviUivovzhvUmhsrvowOlyq@:DWORD
_CreateProcessNotifyRoutineActivated DB 01H DUP (?)
;	COMDAT ??_C@_1DE@MLPIADGK@?$AAZ?$AAw?$AAQ?$AAu?$AAe?$AAr?$AAy?$AAI?$AAn?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AAi?$AAo?$AAn?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@MLPIADGK@?$AAZ?$AAw?$AAQ?$AAu?$AAe?$AAr?$AAy?$AAI?$AAn?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AAi?$AAo?$AAn?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$AA@ DB 'Z'
	DB	00H, 'w', 00H, 'Q', 00H, 'u', 00H, 'e', 00H, 'r', 00H, 'y', 00H
	DB	'I', 00H, 'n', 00H, 'f', 00H, 'o', 00H, 'r', 00H, 'm', 00H, 'a'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'P', 00H, 'r', 00H
	DB	'o', 00H, 'c', 00H, 'e', 00H, 's', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@HCBGJDP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAN?$AAS?$AAH?$AAI?$AAE?$AAL?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@HCBGJDP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAN?$AAS?$AAH?$AAI?$AAE?$AAL?$AAD?$AA?$AA@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'N', 00H, 'S', 00H, 'H', 00H, 'I', 00H, 'E', 00H, 'L'
	DB	00H, 'D', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@LPCKBFKB@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAN?$AAS?$AAH?$AAI?$AAE?$AAL?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@LPCKBFKB@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAN?$AAS?$AAH?$AAI?$AAE?$AAL?$AAD?$AA?$AA@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'N', 00H, 'S'
	DB	00H, 'H', 00H, 'I', 00H, 'E', 00H, 'L', 00H, 'D', 00H, 00H, 00H ; `string'
CONST	ENDS
PUBLIC	_DispatchClose@8
; Function compile flags: /Odtp
; File d:\yudha projects\n-shield antivirus\source\driver\nshield.c
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_DispatchClose@8 PROC

; 269  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 270  :     Irp->IoStatus.Status = STATUS_SUCCESS;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00006	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 271  :     Irp->IoStatus.Information = 0;

  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00010	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 272  :     IoCompleteRequest(Irp, IO_NO_INCREMENT);

  00017	32 d2		 xor	 dl, dl
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 273  :     return STATUS_SUCCESS;

  00022	33 c0		 xor	 eax, eax

; 274  : }

  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
_DispatchClose@8 ENDP
_TEXT	ENDS
PUBLIC	_DispatchCreate@8
; Function compile flags: /Odtp
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_DispatchCreate@8 PROC

; 261  : {

  00030	55		 push	 ebp
  00031	8b ec		 mov	 ebp, esp

; 262  :     Irp->IoStatus.Status = STATUS_SUCCESS;

  00033	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00036	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 263  :     Irp->IoStatus.Information = 0;

  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00040	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 264  :     IoCompleteRequest(Irp, IO_NO_INCREMENT);

  00047	32 d2		 xor	 dl, dl
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 265  :     return STATUS_SUCCESS;

  00052	33 c0		 xor	 eax, eax

; 266  : }

  00054	5d		 pop	 ebp
  00055	c2 08 00	 ret	 8
_DispatchCreate@8 ENDP
_TEXT	ENDS
PUBLIC	_OpenProcess@12
EXTRN	__except_handler3:PROC
xdata$x	SEGMENT
__sehtable$_OpenProcess@12 DD 0ffffffffH
	DD	FLAT:$LN7@OpenProces
	DD	FLAT:$LN8@OpenProces
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_Process$ = -36						; size = 4
_ProcessObject$ = -32					; size = 4
_Status$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_ProcessId$ = 8						; size = 4
_DesiredAccess$ = 12					; size = 4
_ProcessHandle$ = 16					; size = 4
_OpenProcess@12 PROC

; 94   : {

  00060	55		 push	 ebp
  00061	8b ec		 mov	 ebp, esp
  00063	6a ff		 push	 -1
  00065	68 00 00 00 00	 push	 OFFSET __sehtable$_OpenProcess@12
  0006a	68 00 00 00 00	 push	 OFFSET __except_handler3
  0006f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00075	50		 push	 eax
  00076	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:0, esp
  0007d	83 c4 ec	 add	 esp, -20		; ffffffecH
  00080	53		 push	 ebx
  00081	56		 push	 esi
  00082	57		 push	 edi
  00083	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 95   :     NTSTATUS Status;
; 96   :     PEPROCESS ProcessObject;
; 97   : 	HANDLE Process;
; 98   : 	
; 99   : 	__try 

  00086	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 100  : 	{
; 101  : 	    Status = PsLookupProcessByProcessId(ProcessId, &ProcessObject);

  0008d	8d 45 e0	 lea	 eax, DWORD PTR _ProcessObject$[ebp]
  00090	50		 push	 eax
  00091	8b 4d 08	 mov	 ecx, DWORD PTR _ProcessId$[ebp]
  00094	51		 push	 ecx
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsLookupProcessByProcessId@8
  0009b	89 45 e4	 mov	 DWORD PTR _Status$[ebp], eax

; 102  : 	
; 103  : 	    if (Status == STATUS_SUCCESS) 

  0009e	83 7d e4 00	 cmp	 DWORD PTR _Status$[ebp], 0
  000a2	75 31		 jne	 SHORT $LN3@OpenProces

; 104  :         {                            
; 105  :             Status = ObOpenObjectByPointer (ProcessObject, 0, NULL, DesiredAccess, *PsProcessType, KernelMode, &Process); 

  000a4	8d 55 dc	 lea	 edx, DWORD PTR _Process$[ebp]
  000a7	52		 push	 edx
  000a8	6a 00		 push	 0
  000aa	a1 00 00 00 00	 mov	 eax, DWORD PTR _PsProcessType
  000af	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b1	51		 push	 ecx
  000b2	8b 55 0c	 mov	 edx, DWORD PTR _DesiredAccess$[ebp]
  000b5	52		 push	 edx
  000b6	6a 00		 push	 0
  000b8	6a 00		 push	 0
  000ba	8b 45 e0	 mov	 eax, DWORD PTR _ProcessObject$[ebp]
  000bd	50		 push	 eax
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ObOpenObjectByPointer@28
  000c4	89 45 e4	 mov	 DWORD PTR _Status$[ebp], eax

; 106  : 		    if (Status == STATUS_SUCCESS) 

  000c7	83 7d e4 00	 cmp	 DWORD PTR _Status$[ebp], 0
  000cb	75 08		 jne	 SHORT $LN3@OpenProces

; 107  : 	        { 	
; 108  :                 *ProcessHandle = Process; 

  000cd	8b 4d 10	 mov	 ecx, DWORD PTR _ProcessHandle$[ebp]
  000d0	8b 55 dc	 mov	 edx, DWORD PTR _Process$[ebp]
  000d3	89 11		 mov	 DWORD PTR [ecx], edx
$LN3@OpenProces:

; 109  : 	        }
; 110  :         } 			
; 111  : 	}							

  000d5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
  000dc	eb 10		 jmp	 SHORT $LN10@OpenProces
$LN7@OpenProces:
$LN12@OpenProces:

; 112  : 	__except( EXCEPTION_EXECUTE_HANDLER )  

  000de	b8 01 00 00 00	 mov	 eax, 1
$LN9@OpenProces:
$LN11@OpenProces:
  000e3	c3		 ret	 0
$LN8@OpenProces:
  000e4	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 113  : 	{   
; 114  : 	}	

  000e7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
$LN10@OpenProces:

; 115  : 	
; 116  :     return Status;

  000ee	8b 45 e4	 mov	 eax, DWORD PTR _Status$[ebp]
$LN6@OpenProces:

; 117  : }

  000f1	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  000f4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000fb	5f		 pop	 edi
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx
  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c2 0c 00	 ret	 12			; 0000000cH
_OpenProcess@12 ENDP
_TEXT	ENDS
PUBLIC	_GetSystemRoutineAddress@4
xdata$x	SEGMENT
	ORG $+4
__sehtable$_GetSystemRoutineAddress@4 DD 0ffffffffH
	DD	FLAT:$LN5@GetSystemR
	DD	FLAT:$LN6@GetSystemR
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_RoutineName$ = -36					; size = 8
_RoutineAddress$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_Name$ = 8						; size = 4
_GetSystemRoutineAddress@4 PROC

; 59   : {

  00110	55		 push	 ebp
  00111	8b ec		 mov	 ebp, esp
  00113	6a ff		 push	 -1
  00115	68 00 00 00 00	 push	 OFFSET __sehtable$_GetSystemRoutineAddress@4
  0011a	68 00 00 00 00	 push	 OFFSET __except_handler3
  0011f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00125	50		 push	 eax
  00126	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:0, esp
  0012d	83 c4 ec	 add	 esp, -20		; ffffffecH
  00130	53		 push	 ebx
  00131	56		 push	 esi
  00132	57		 push	 edi
  00133	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 60   :   UNICODE_STRING RoutineName;
; 61   :   PVOID RoutineAddress = NULL;

  00136	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _RoutineAddress$[ebp], 0

; 62   :     
; 63   :   RtlInitUnicodeString(&RoutineName, Name);

  0013d	8b 45 08	 mov	 eax, DWORD PTR _Name$[ebp]
  00140	50		 push	 eax
  00141	8d 4d dc	 lea	 ecx, DWORD PTR _RoutineName$[ebp]
  00144	51		 push	 ecx
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 64   : 
; 65   :   try

  0014b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 66   :   {
; 67   :       RoutineAddress = MmGetSystemRoutineAddress(&RoutineName);

  00152	8d 55 dc	 lea	 edx, DWORD PTR _RoutineName$[ebp]
  00155	52		 push	 edx
  00156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmGetSystemRoutineAddress@4
  0015c	89 45 e4	 mov	 DWORD PTR _RoutineAddress$[ebp], eax

; 68   :   }

  0015f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
  00166	eb 17		 jmp	 SHORT $LN8@GetSystemR
$LN5@GetSystemR:
$LN10@GetSystemR:

; 69   :   except (EXCEPTION_EXECUTE_HANDLER)

  00168	b8 01 00 00 00	 mov	 eax, 1
$LN7@GetSystemR:
$LN9@GetSystemR:
  0016d	c3		 ret	 0
$LN6@GetSystemR:
  0016e	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 70   :   {
; 71   :       RoutineAddress = NULL;

  00171	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _RoutineAddress$[ebp], 0

; 72   :   }

  00178	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
$LN8@GetSystemR:

; 73   :     
; 74   :   return RoutineAddress;

  0017f	8b 45 e4	 mov	 eax, DWORD PTR _RoutineAddress$[ebp]
$LN4@GetSystemR:

; 75   : }

  00182	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00185	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0018c	5f		 pop	 edi
  0018d	5e		 pop	 esi
  0018e	5b		 pop	 ebx
  0018f	8b e5		 mov	 esp, ebp
  00191	5d		 pop	 ebp
  00192	c2 04 00	 ret	 4
_GetSystemRoutineAddress@4 ENDP
_TEXT	ENDS
PUBLIC	_ProcessCallback@12
; Function compile flags: /Odtp
_TEXT	SEGMENT
_ParentId$ = 8						; size = 4
_ProcessId$ = 12					; size = 4
_Create$ = 16						; size = 1
_ProcessCallback@12 PROC

; 38   : {

  001a0	55		 push	 ebp
  001a1	8b ec		 mov	 ebp, esp

; 39   : 	if (HostProcessId != PsGetCurrentProcessId())

  001a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsGetCurrentProcessId@0
  001a9	39 05 00 00 00
	00		 cmp	 DWORD PTR _HostProcessId, eax
  001af	74 3f		 je	 SHORT $LN2@ProcessCal

; 40   : 	{
; 41   : 		ProcessMonitorCallbackInfo->ParentId = ParentId;

  001b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _ProcessMonitorCallbackInfo
  001b6	8b 4d 08	 mov	 ecx, DWORD PTR _ParentId$[ebp]
  001b9	89 08		 mov	 DWORD PTR [eax], ecx

; 42   : 		ProcessMonitorCallbackInfo->ProcessId = ProcessId;

  001bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ProcessMonitorCallbackInfo
  001c1	8b 45 0c	 mov	 eax, DWORD PTR _ProcessId$[ebp]
  001c4	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 43   : 		ProcessMonitorCallbackInfo->Create = Create;

  001c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ProcessMonitorCallbackInfo
  001cd	8a 55 10	 mov	 dl, BYTE PTR _Create$[ebp]
  001d0	88 51 08	 mov	 BYTE PTR [ecx+8], dl

; 44   : 		KeSetEvent(ProcessMonitorEvent, 0, FALSE);

  001d3	6a 00		 push	 0
  001d5	6a 00		 push	 0
  001d7	a1 00 00 00 00	 mov	 eax, DWORD PTR _ProcessMonitorEvent
  001dc	50		 push	 eax
  001dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 45   : 		KeClearEvent(ProcessMonitorEvent);

  001e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ProcessMonitorEvent
  001e9	51		 push	 ecx
  001ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeClearEvent@4
$LN2@ProcessCal:

; 46   : 	}
; 47   : }

  001f0	5d		 pop	 ebp
  001f1	c2 0c 00	 ret	 12			; 0000000cH
_ProcessCallback@12 ENDP
; Function compile flags: /Odtp
; File d:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _IoGetCurrentIrpStackLocation@4
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_IoGetCurrentIrpStackLocation@4 PROC			; COMDAT

; 23316: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);
; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

  00003	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00006	8b 40 60	 mov	 eax, DWORD PTR [eax+96]

; 23319: }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
_IoGetCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	_UnloadDriver@4
; Function compile flags: /Odtp
; File d:\yudha projects\n-shield antivirus\source\driver\nshield.c
_TEXT	SEGMENT
_DeviceName$ = -12					; size = 8
_Status$ = -4						; size = 4
_DriverObject$ = 8					; size = 4
_UnloadDriver@4 PROC

; 200  : {

  00200	55		 push	 ebp
  00201	8b ec		 mov	 ebp, esp
  00203	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 201  :     NTSTATUS        Status;
; 202  :     UNICODE_STRING  DeviceName;
; 203  : 		
; 204  : 	if (CreateProcessNotifyRoutineActivated) 

  00206	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _CreateProcessNotifyRoutineActivated
  0020d	85 c0		 test	 eax, eax
  0020f	74 1d		 je	 SHORT $LN3@UnloadDriv

; 205  : 	{
; 206  : 		Status = PsSetCreateProcessNotifyRoutine(ProcessCallback, TRUE);

  00211	6a 01		 push	 1
  00213	68 00 00 00 00	 push	 OFFSET _ProcessCallback@12
  00218	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsSetCreateProcessNotifyRoutine@8
  0021e	89 45 fc	 mov	 DWORD PTR _Status$[ebp], eax

; 207  : 		if (Status == STATUS_SUCCESS)

  00221	83 7d fc 00	 cmp	 DWORD PTR _Status$[ebp], 0
  00225	75 07		 jne	 SHORT $LN3@UnloadDriv

; 208  : 		{
; 209  : 			CreateProcessNotifyRoutineActivated = FALSE;	

  00227	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _CreateProcessNotifyRoutineActivated, 0
$LN3@UnloadDriv:

; 210  :         }
; 211  : 	}	
; 212  : 	
; 213  : 	if (ProcessMonitorEvent != NULL)

  0022e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ProcessMonitorEvent, 0
  00235	74 23		 je	 SHORT $LN1@UnloadDriv

; 214  :     {
; 215  : 		KeClearEvent(ProcessMonitorEvent);

  00237	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ProcessMonitorEvent
  0023d	51		 push	 ecx
  0023e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeClearEvent@4

; 216  :         ObfDereferenceObject(ProcessMonitorEvent);

  00244	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ProcessMonitorEvent
  0024a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 217  :         ProcessMonitorEvent = NULL;

  00250	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ProcessMonitorEvent, 0
$LN1@UnloadDriv:

; 218  :     }
; 219  : 	
; 220  :     IoDeleteDevice(DriverObject->DeviceObject);

  0025a	8b 55 08	 mov	 edx, DWORD PTR _DriverObject$[ebp]
  0025d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00260	50		 push	 eax
  00261	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4

; 221  : 
; 222  :     RtlInitUnicodeString(&DeviceName, L"\\DosDevices\\NSHIELD");

  00267	68 00 00 00 00	 push	 OFFSET ??_C@_1CI@LPCKBFKB@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAN?$AAS?$AAH?$AAI?$AAE?$AAL?$AAD?$AA?$AA@
  0026c	8d 4d f4	 lea	 ecx, DWORD PTR _DeviceName$[ebp]
  0026f	51		 push	 ecx
  00270	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 223  :     IoDeleteSymbolicLink(&DeviceName);

  00276	8d 55 f4	 lea	 edx, DWORD PTR _DeviceName$[ebp]
  00279	52		 push	 edx
  0027a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteSymbolicLink@4

; 224  : }

  00280	8b e5		 mov	 esp, ebp
  00282	5d		 pop	 ebp
  00283	c2 04 00	 ret	 4
_UnloadDriver@4 ENDP
_TEXT	ENDS
PUBLIC	_GetProcessImageName@8
xdata$x	SEGMENT
	ORG $+4
__sehtable$_GetProcessImageName@8 DD 0ffffffffH
	DD	FLAT:$LN14@GetProcess
	DD	FLAT:$LN15@GetProcess
	DD	00H
	DD	FLAT:$LN18@GetProcess
	DD	FLAT:$LN19@GetProcess
	DD	00H
	DD	FLAT:$LN22@GetProcess
	DD	FLAT:$LN23@GetProcess
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv154 = -64						; size = 4
tv151 = -60						; size = 4
tv149 = -56						; size = 4
tv146 = -52						; size = 4
tv144 = -48						; size = 4
tv142 = -44						; size = 4
_ProcessInformationLength$ = -40			; size = 4
_Status$ = -36						; size = 4
_ProcessHandle$ = -32					; size = 4
_ProcessInformation$ = -28				; size = 4
__$SEHRec$ = -24					; size = 24
_ProcessId$ = 8						; size = 4
_ProcessPath$ = 12					; size = 4
_GetProcessImageName@8 PROC

; 120  : {

  00290	55		 push	 ebp
  00291	8b ec		 mov	 ebp, esp
  00293	6a ff		 push	 -1
  00295	68 00 00 00 00	 push	 OFFSET __sehtable$_GetProcessImageName@8
  0029a	68 00 00 00 00	 push	 OFFSET __except_handler3
  0029f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  002a5	50		 push	 eax
  002a6	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:0, esp
  002ad	83 c4 d0	 add	 esp, -48		; ffffffd0H
  002b0	53		 push	 ebx
  002b1	56		 push	 esi
  002b2	57		 push	 edi
  002b3	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 121  :     NTSTATUS Status = STATUS_UNSUCCESSFUL;

  002b6	c7 45 dc 01 00
	00 c0		 mov	 DWORD PTR _Status$[ebp], -1073741823 ; c0000001H

; 122  :     ULONG ProcessInformationLength;
; 123  : 	HANDLE ProcessHandle;
; 124  :     PVOID ProcessInformation;
; 125  :     
; 126  : 	if(KeGetCurrentIrql() == PASSIVE_LEVEL)

  002bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentIrql@0
  002c3	0f b6 c0	 movzx	 eax, al
  002c6	85 c0		 test	 eax, eax
  002c8	0f 85 e5 01 00
	00		 jne	 $LN10@GetProcess

; 127  : 	{
; 128  : 		__try 

  002ce	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 129  : 		{	    
; 130  : 			if (!ZwQueryInformationProcess)

  002d5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ZwQueryInformationProcess, 0
  002dc	75 15		 jne	 SHORT $LN8@GetProcess

; 131  : 			{
; 132  : 				return Status;

  002de	8b 4d dc	 mov	 ecx, DWORD PTR _Status$[ebp]
  002e1	89 4d d4	 mov	 DWORD PTR tv142[ebp], ecx
  002e4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
  002eb	8b 45 d4	 mov	 eax, DWORD PTR tv142[ebp]
  002ee	e9 c3 01 00 00	 jmp	 $LN13@GetProcess
$LN8@GetProcess:

; 133  : 			}
; 134  : 		
; 135  : 			Status = OpenProcess(ProcessId, PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, &ProcessHandle);

  002f3	8d 55 e0	 lea	 edx, DWORD PTR _ProcessHandle$[ebp]
  002f6	52		 push	 edx
  002f7	68 10 04 00 00	 push	 1040			; 00000410H
  002fc	8b 45 08	 mov	 eax, DWORD PTR _ProcessId$[ebp]
  002ff	50		 push	 eax
  00300	e8 00 00 00 00	 call	 _OpenProcess@12
  00305	89 45 dc	 mov	 DWORD PTR _Status$[ebp], eax

; 136  : 
; 137  : 			if (Status == STATUS_SUCCESS) 

  00308	83 7d dc 00	 cmp	 DWORD PTR _Status$[ebp], 0
  0030c	0f 85 81 01 00
	00		 jne	 $LN9@GetProcess

; 138  : 			{   
; 139  : 				Status = ZwQueryInformationProcess(ProcessHandle, ProcessImageFileName, NULL, 0, &ProcessInformationLength);

  00312	8d 4d d8	 lea	 ecx, DWORD PTR _ProcessInformationLength$[ebp]
  00315	51		 push	 ecx
  00316	6a 00		 push	 0
  00318	6a 00		 push	 0
  0031a	6a 1b		 push	 27			; 0000001bH
  0031c	8b 55 e0	 mov	 edx, DWORD PTR _ProcessHandle$[ebp]
  0031f	52		 push	 edx
  00320	ff 15 00 00 00
	00		 call	 DWORD PTR _ZwQueryInformationProcess
  00326	89 45 dc	 mov	 DWORD PTR _Status$[ebp], eax

; 140  : 
; 141  : 				if (STATUS_INFO_LENGTH_MISMATCH != Status) 

  00329	81 7d dc 04 00
	00 c0		 cmp	 DWORD PTR _Status$[ebp], -1073741820 ; c0000004H
  00330	74 1f		 je	 SHORT $LN6@GetProcess

; 142  : 				{
; 143  : 					ZwClose(ProcessHandle);

  00332	8b 45 e0	 mov	 eax, DWORD PTR _ProcessHandle$[ebp]
  00335	50		 push	 eax
  00336	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 144  : 					return Status;

  0033c	8b 4d dc	 mov	 ecx, DWORD PTR _Status$[ebp]
  0033f	89 4d d0	 mov	 DWORD PTR tv144[ebp], ecx
  00342	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
  00349	8b 45 d0	 mov	 eax, DWORD PTR tv144[ebp]
  0034c	e9 65 01 00 00	 jmp	 $LN13@GetProcess
$LN6@GetProcess:

; 145  : 				}
; 146  : 
; 147  : 				ProcessInformation = ExAllocatePoolWithTag(NonPagedPool, ProcessInformationLength, 'TgPI');

  00351	68 49 50 67 54	 push	 1416056905		; 54675049H
  00356	8b 55 d8	 mov	 edx, DWORD PTR _ProcessInformationLength$[ebp]
  00359	52		 push	 edx
  0035a	6a 00		 push	 0
  0035c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00362	89 45 e4	 mov	 DWORD PTR _ProcessInformation$[ebp], eax

; 148  : 
; 149  : 				if (NULL == ProcessInformation) 

  00365	83 7d e4 00	 cmp	 DWORD PTR _ProcessInformation$[ebp], 0
  00369	75 20		 jne	 SHORT $LN5@GetProcess

; 150  : 				{
; 151  : 					ZwClose(ProcessHandle);

  0036b	8b 45 e0	 mov	 eax, DWORD PTR _ProcessHandle$[ebp]
  0036e	50		 push	 eax
  0036f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 152  : 					return STATUS_INSUFFICIENT_RESOURCES;   

  00375	c7 45 cc 9a 00
	00 c0		 mov	 DWORD PTR tv146[ebp], -1073741670 ; c000009aH
  0037c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
  00383	8b 45 cc	 mov	 eax, DWORD PTR tv146[ebp]
  00386	e9 2b 01 00 00	 jmp	 $LN13@GetProcess
$LN5@GetProcess:

; 153  : 				}
; 154  : 			
; 155  : 				__try 

  0038b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 1

; 156  : 				{
; 157  : 					Status = ZwQueryInformationProcess( ProcessHandle, ProcessImageFileName, ProcessInformation, ProcessInformationLength, &ProcessInformationLength);

  00392	8d 4d d8	 lea	 ecx, DWORD PTR _ProcessInformationLength$[ebp]
  00395	51		 push	 ecx
  00396	8b 55 d8	 mov	 edx, DWORD PTR _ProcessInformationLength$[ebp]
  00399	52		 push	 edx
  0039a	8b 45 e4	 mov	 eax, DWORD PTR _ProcessInformation$[ebp]
  0039d	50		 push	 eax
  0039e	6a 1b		 push	 27			; 0000001bH
  003a0	8b 4d e0	 mov	 ecx, DWORD PTR _ProcessHandle$[ebp]
  003a3	51		 push	 ecx
  003a4	ff 15 00 00 00
	00		 call	 DWORD PTR _ZwQueryInformationProcess
  003aa	89 45 dc	 mov	 DWORD PTR _Status$[ebp], eax

; 158  : 				}							

  003ad	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0
  003b4	eb 3c		 jmp	 SHORT $LN21@GetProcess
$LN18@GetProcess:
$LN29@GetProcess:

; 159  : 				__except( EXCEPTION_EXECUTE_HANDLER )  

  003b6	b8 01 00 00 00	 mov	 eax, 1
$LN20@GetProcess:
$LN26@GetProcess:
  003bb	c3		 ret	 0
$LN19@GetProcess:
  003bc	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 160  : 				{   
; 161  : 					ZwClose(ProcessHandle);

  003bf	8b 55 e0	 mov	 edx, DWORD PTR _ProcessHandle$[ebp]
  003c2	52		 push	 edx
  003c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 162  : 					ExFreePool(ProcessInformation);

  003c9	6a 00		 push	 0
  003cb	8b 45 e4	 mov	 eax, DWORD PTR _ProcessInformation$[ebp]
  003ce	50		 push	 eax
  003cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 163  : 					return  STATUS_UNSUCCESSFUL;						

  003d5	c7 45 c8 01 00
	00 c0		 mov	 DWORD PTR tv149[ebp], -1073741823 ; c0000001H
  003dc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
  003e3	8b 45 c8	 mov	 eax, DWORD PTR tv149[ebp]
  003e6	e9 cb 00 00 00	 jmp	 $LN13@GetProcess

; 164  : 				}	

  003eb	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0
$LN21@GetProcess:

; 165  : 		
; 166  : 				ZwClose(ProcessHandle);

  003f2	8b 4d e0	 mov	 ecx, DWORD PTR _ProcessHandle$[ebp]
  003f5	51		 push	 ecx
  003f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4

; 167  : 			
; 168  : 				if (Status == STATUS_SUCCESS) 

  003fc	83 7d dc 00	 cmp	 DWORD PTR _Status$[ebp], 0
  00400	0f 85 81 00 00
	00		 jne	 $LN3@GetProcess

; 169  : 				{ 
; 170  : 					if (ProcessInformationLength > MAXPATHLEN)

  00406	81 7d d8 ff 00
	00 00		 cmp	 DWORD PTR _ProcessInformationLength$[ebp], 255 ; 000000ffH
  0040d	76 22		 jbe	 SHORT $LN2@GetProcess

; 171  : 					{			    
; 172  : 						ExFreePool(ProcessInformation);

  0040f	6a 00		 push	 0
  00411	8b 55 e4	 mov	 edx, DWORD PTR _ProcessInformation$[ebp]
  00414	52		 push	 edx
  00415	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 173  : 						return  STATUS_UNSUCCESSFUL;

  0041b	c7 45 c4 01 00
	00 c0		 mov	 DWORD PTR tv151[ebp], -1073741823 ; c0000001H
  00422	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
  00429	8b 45 c4	 mov	 eax, DWORD PTR tv151[ebp]
  0042c	e9 85 00 00 00	 jmp	 $LN13@GetProcess
$LN2@GetProcess:

; 174  : 					}		
; 175  : 					
; 176  : 					__try 

  00431	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 2

; 177  : 					{			   				        
; 178  : 						wcsncat(ProcessPath, ((PUNICODE_STRING)ProcessInformation)->Buffer, ProcessInformationLength);	

  00438	8b 45 d8	 mov	 eax, DWORD PTR _ProcessInformationLength$[ebp]
  0043b	50		 push	 eax
  0043c	8b 4d e4	 mov	 ecx, DWORD PTR _ProcessInformation$[ebp]
  0043f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00442	52		 push	 edx
  00443	8b 45 0c	 mov	 eax, DWORD PTR _ProcessPath$[ebp]
  00446	50		 push	 eax
  00447	e8 00 00 00 00	 call	 _wcsncat
  0044c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 179  : 					}

  0044f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0
  00456	eb 2f		 jmp	 SHORT $LN3@GetProcess
$LN22@GetProcess:
$LN30@GetProcess:

; 180  : 					__except( EXCEPTION_EXECUTE_HANDLER )  

  00458	b8 01 00 00 00	 mov	 eax, 1
$LN24@GetProcess:
$LN27@GetProcess:
  0045d	c3		 ret	 0
$LN23@GetProcess:
  0045e	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 181  : 					{   
; 182  : 						ExFreePool(ProcessInformation);

  00461	6a 00		 push	 0
  00463	8b 4d e4	 mov	 ecx, DWORD PTR _ProcessInformation$[ebp]
  00466	51		 push	 ecx
  00467	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 183  : 						return  STATUS_UNSUCCESSFUL;						

  0046d	c7 45 c0 01 00
	00 c0		 mov	 DWORD PTR tv154[ebp], -1073741823 ; c0000001H
  00474	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
  0047b	8b 45 c0	 mov	 eax, DWORD PTR tv154[ebp]
  0047e	eb 36		 jmp	 SHORT $LN13@GetProcess

; 184  : 					}	

  00480	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0
$LN3@GetProcess:

; 185  : 				}
; 186  :  
; 187  : 				ExFreePool(ProcessInformation);

  00487	6a 00		 push	 0
  00489	8b 55 e4	 mov	 edx, DWORD PTR _ProcessInformation$[ebp]
  0048c	52		 push	 edx
  0048d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN9@GetProcess:

; 188  : 			}
; 189  : 		}

  00493	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
  0049a	eb 17		 jmp	 SHORT $LN10@GetProcess
$LN14@GetProcess:
$LN31@GetProcess:

; 190  : 		__except( EXCEPTION_EXECUTE_HANDLER )  

  0049c	b8 01 00 00 00	 mov	 eax, 1
$LN16@GetProcess:
$LN28@GetProcess:
  004a1	c3		 ret	 0
$LN15@GetProcess:
  004a2	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 191  : 		{       
; 192  : 			Status = STATUS_UNSUCCESSFUL;						

  004a5	c7 45 dc 01 00
	00 c0		 mov	 DWORD PTR _Status$[ebp], -1073741823 ; c0000001H

; 193  : 		}

  004ac	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
$LN10@GetProcess:

; 194  : 	}
; 195  : 
; 196  :     return Status;

  004b3	8b 45 dc	 mov	 eax, DWORD PTR _Status$[ebp]
$LN13@GetProcess:

; 197  : }

  004b6	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  004b9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004c0	5f		 pop	 edi
  004c1	5e		 pop	 esi
  004c2	5b		 pop	 ebx
  004c3	8b e5		 mov	 esp, ebp
  004c5	5d		 pop	 ebp
  004c6	c2 08 00	 ret	 8
_GetProcessImageName@8 ENDP
_TEXT	ENDS
PUBLIC	_DispatchIoCtl@8
xdata$x	SEGMENT
	ORG $+4
__sehtable$_DispatchIoCtl@8 DD 0ffffffffH
	DD	FLAT:$LN22@DispatchIo
	DD	FLAT:$LN23@DispatchIo
	DD	0ffffffffH
	DD	FLAT:$LN26@DispatchIo
	DD	FLAT:$LN27@DispatchIo
	DD	0ffffffffH
	DD	FLAT:$LN30@DispatchIo
	DD	FLAT:$LN31@DispatchIo
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv67 = -64						; size = 4
_OpenProcessCallbackInfo$30066 = -60			; size = 4
_ProcessHandle$30064 = -56				; size = 4
_OpenProcessInfo$30062 = -52				; size = 8
_Path$30054 = -44					; size = 4
_ProcessMonitorInfo$30038 = -40				; size = 8
_Status$ = -32						; size = 4
_IrpStack$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_DispatchIoCtl@8 PROC

; 284  : {

  004d0	55		 push	 ebp
  004d1	8b ec		 mov	 ebp, esp
  004d3	6a ff		 push	 -1
  004d5	68 00 00 00 00	 push	 OFFSET __sehtable$_DispatchIoCtl@8
  004da	68 00 00 00 00	 push	 OFFSET __except_handler3
  004df	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  004e5	50		 push	 eax
  004e6	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:0, esp
  004ed	83 c4 d0	 add	 esp, -48		; ffffffd0H
  004f0	53		 push	 ebx
  004f1	56		 push	 esi
  004f2	57		 push	 edi
  004f3	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 285  :     NTSTATUS            Status = STATUS_UNSUCCESSFUL;

  004f6	c7 45 e0 01 00
	00 c0		 mov	 DWORD PTR _Status$[ebp], -1073741823 ; c0000001H

; 286  :     PIO_STACK_LOCATION  IrpStack  = IoGetCurrentIrpStackLocation(Irp);

  004fd	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00500	50		 push	 eax
  00501	e8 00 00 00 00	 call	 _IoGetCurrentIrpStackLocation@4
  00506	89 45 e4	 mov	 DWORD PTR _IrpStack$[ebp], eax

; 287  : 		
; 288  :     switch(IrpStack->Parameters.DeviceIoControl.IoControlCode)

  00509	8b 4d e4	 mov	 ecx, DWORD PTR _IrpStack$[ebp]
  0050c	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0050f	89 55 c0	 mov	 DWORD PTR tv67[ebp], edx
  00512	81 7d c0 04 24
	00 f1		 cmp	 DWORD PTR tv67[ebp], -251649020 ; f1002404H
  00519	74 1f		 je	 SHORT $LN16@DispatchIo
  0051b	81 7d c0 08 24
	00 f1		 cmp	 DWORD PTR tv67[ebp], -251649016 ; f1002408H
  00522	0f 84 b8 00 00
	00		 je	 $LN10@DispatchIo
  00528	81 7d c0 0c 24
	00 f1		 cmp	 DWORD PTR tv67[ebp], -251649012 ; f100240cH
  0052f	0f 84 82 01 00
	00		 je	 $LN5@DispatchIo
  00535	e9 11 02 00 00	 jmp	 $LN17@DispatchIo
$LN16@DispatchIo:

; 289  :     {					
; 290  : 		case IOCTL_START_PROCESS_MONITOR:
; 291  : 	    { 
; 292  : 		    if (IrpStack->Parameters.DeviceIoControl.InputBufferLength >= sizeof(TProcessMonitorInfo)) 

  0053a	8b 45 e4	 mov	 eax, DWORD PTR _IrpStack$[ebp]
  0053d	83 78 08 08	 cmp	 DWORD PTR [eax+8], 8
  00541	0f 82 94 00 00
	00		 jb	 $LN15@DispatchIo

; 293  : 			{
; 294  : 			    __try

  00547	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 295  : 				{
; 296  : 		            TProcessMonitorInfo ProcessMonitorInfo = *(PProcessMonitorInfo)Irp->AssociatedIrp.SystemBuffer;

  0054e	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00551	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00554	8b 02		 mov	 eax, DWORD PTR [edx]
  00556	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00559	89 45 d8	 mov	 DWORD PTR _ProcessMonitorInfo$30038[ebp], eax
  0055c	89 4d dc	 mov	 DWORD PTR _ProcessMonitorInfo$30038[ebp+4], ecx

; 297  : 
; 298  : 		            HostProcessId = ProcessMonitorInfo.HostProcessId;

  0055f	8b 55 dc	 mov	 edx, DWORD PTR _ProcessMonitorInfo$30038[ebp+4]
  00562	89 15 00 00 00
	00		 mov	 DWORD PTR _HostProcessId, edx

; 299  : 		            Status = ObReferenceObjectByHandle( (HANDLE)ProcessMonitorInfo.ProcessMonitorEvent,  EVENT_MODIFY_STATE, *ExEventObjectType, UserMode, (PVOID*)&ProcessMonitorEvent, NULL);

  00568	6a 00		 push	 0
  0056a	68 00 00 00 00	 push	 OFFSET _ProcessMonitorEvent
  0056f	6a 01		 push	 1
  00571	a1 00 00 00 00	 mov	 eax, DWORD PTR _ExEventObjectType
  00576	8b 08		 mov	 ecx, DWORD PTR [eax]
  00578	51		 push	 ecx
  00579	6a 02		 push	 2
  0057b	8b 55 d8	 mov	 edx, DWORD PTR _ProcessMonitorInfo$30038[ebp]
  0057e	52		 push	 edx
  0057f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ObReferenceObjectByHandle@24
  00585	89 45 e0	 mov	 DWORD PTR _Status$[ebp], eax

; 300  : 
; 301  : 			        if (Status == STATUS_SUCCESS)

  00588	83 7d e0 00	 cmp	 DWORD PTR _Status$[ebp], 0
  0058c	75 28		 jne	 SHORT $LN13@DispatchIo

; 302  : 			        {
; 303  : 				        if (!CreateProcessNotifyRoutineActivated) 

  0058e	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _CreateProcessNotifyRoutineActivated
  00595	85 c0		 test	 eax, eax
  00597	75 1d		 jne	 SHORT $LN13@DispatchIo

; 304  : 				        {
; 305  : 					        Status = PsSetCreateProcessNotifyRoutine(ProcessCallback, FALSE);

  00599	6a 00		 push	 0
  0059b	68 00 00 00 00	 push	 OFFSET _ProcessCallback@12
  005a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PsSetCreateProcessNotifyRoutine@8
  005a6	89 45 e0	 mov	 DWORD PTR _Status$[ebp], eax

; 306  : 					        if (Status == STATUS_SUCCESS)

  005a9	83 7d e0 00	 cmp	 DWORD PTR _Status$[ebp], 0
  005ad	75 07		 jne	 SHORT $LN13@DispatchIo

; 307  : 					        {
; 308  : 						        CreateProcessNotifyRoutineActivated = TRUE;				

  005af	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _CreateProcessNotifyRoutineActivated, 1
$LN13@DispatchIo:

; 309  : 					        }
; 310  : 				        }
; 311  : 			        }
; 312  : 			        Irp->IoStatus.Information = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

  005b6	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  005b9	8b 55 e4	 mov	 edx, DWORD PTR _IrpStack$[ebp]
  005bc	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  005bf	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 313  : 				}

  005c2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
  005c9	eb 10		 jmp	 SHORT $LN15@DispatchIo
$LN22@DispatchIo:
$LN37@DispatchIo:

; 314  : 	            __except( EXCEPTION_EXECUTE_HANDLER )  

  005cb	b8 01 00 00 00	 mov	 eax, 1
$LN24@DispatchIo:
$LN34@DispatchIo:
  005d0	c3		 ret	 0
$LN23@DispatchIo:
  005d1	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 315  :                 {   					
; 316  :                 } 

  005d4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
$LN15@DispatchIo:

; 317  : 			}			
; 318  :             break;

  005db	e9 6b 01 00 00	 jmp	 $LN17@DispatchIo
$LN10@DispatchIo:

; 319  : 	    }
; 320  : 		
; 321  : 		case IOCTL_GET_PROCESS_MONITOR_DATA:
; 322  : 	    { 
; 323  : 		    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(TProcessMonitorCallbackInfo)) 

  005e0	8b 4d e4	 mov	 ecx, DWORD PTR _IrpStack$[ebp]
  005e3	81 79 04 08 02
	00 00		 cmp	 DWORD PTR [ecx+4], 520	; 00000208H
  005ea	0f 82 c2 00 00
	00		 jb	 $LN9@DispatchIo

; 324  : 			{
; 325  : 			    __try

  005f0	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 1

; 326  : 				{
; 327  : 			        if (ProcessMonitorCallbackInfo != NULL)

  005f7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ProcessMonitorCallbackInfo, 0
  005fe	0f 84 95 00 00
	00		 je	 $LN8@DispatchIo

; 328  : 			        {
; 329  : 					    PWSTR Path = NULL;

  00604	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _Path$30054[ebp], 0

; 330  : 					
; 331  : 				        Path = ExAllocatePoolWithTag(NonPagedPool, MAXPATHLEN, 'TgPH');

  0060b	68 48 50 67 54	 push	 1416056904		; 54675048H
  00610	68 ff 00 00 00	 push	 255			; 000000ffH
  00615	6a 00		 push	 0
  00617	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0061d	89 45 d4	 mov	 DWORD PTR _Path$30054[ebp], eax

; 332  :                         if (Path != NULL)

  00620	83 7d d4 00	 cmp	 DWORD PTR _Path$30054[ebp], 0
  00624	74 44		 je	 SHORT $LN6@DispatchIo

; 333  : 						{
; 334  : 				            GetProcessImageName(ProcessMonitorCallbackInfo->ProcessId, Path);

  00626	8b 55 d4	 mov	 edx, DWORD PTR _Path$30054[ebp]
  00629	52		 push	 edx
  0062a	a1 00 00 00 00	 mov	 eax, DWORD PTR _ProcessMonitorCallbackInfo
  0062f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00632	51		 push	 ecx
  00633	e8 00 00 00 00	 call	 _GetProcessImageName@8

; 335  : 									
; 336  : 					        *ProcessMonitorCallbackInfo->S = L'\0';

  00638	33 d2		 xor	 edx, edx
  0063a	a1 00 00 00 00	 mov	 eax, DWORD PTR _ProcessMonitorCallbackInfo
  0063f	66 89 50 0a	 mov	 WORD PTR [eax+10], dx

; 337  :                             wcsncat(ProcessMonitorCallbackInfo->S, Path, MAXPATHLEN);

  00643	68 ff 00 00 00	 push	 255			; 000000ffH
  00648	8b 4d d4	 mov	 ecx, DWORD PTR _Path$30054[ebp]
  0064b	51		 push	 ecx
  0064c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ProcessMonitorCallbackInfo
  00652	83 c2 0a	 add	 edx, 10			; 0000000aH
  00655	52		 push	 edx
  00656	e8 00 00 00 00	 call	 _wcsncat
  0065b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 338  : 						
; 339  : 							ExFreePool(Path);

  0065e	6a 00		 push	 0
  00660	8b 45 d4	 mov	 eax, DWORD PTR _Path$30054[ebp]
  00663	50		 push	 eax
  00664	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8
$LN6@DispatchIo:

; 340  : 						}
; 341  : 					
; 342  : 			            memcpy(Irp->AssociatedIrp.SystemBuffer, ProcessMonitorCallbackInfo, IrpStack->Parameters.DeviceIoControl.OutputBufferLength);

  0066a	8b 4d e4	 mov	 ecx, DWORD PTR _IrpStack$[ebp]
  0066d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00670	52		 push	 edx
  00671	a1 00 00 00 00	 mov	 eax, DWORD PTR _ProcessMonitorCallbackInfo
  00676	50		 push	 eax
  00677	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0067a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0067d	52		 push	 edx
  0067e	e8 00 00 00 00	 call	 _memcpy
  00683	83 c4 0c	 add	 esp, 12			; 0000000cH

; 343  :                         Irp->IoStatus.Information = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

  00686	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00689	8b 4d e4	 mov	 ecx, DWORD PTR _IrpStack$[ebp]
  0068c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0068f	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 344  : 
; 345  : 			            Status = STATUS_SUCCESS;

  00692	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Status$[ebp], 0
$LN8@DispatchIo:

; 346  : 			        }
; 347  : 				}

  00699	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
  006a0	eb 10		 jmp	 SHORT $LN9@DispatchIo
$LN26@DispatchIo:
$LN38@DispatchIo:

; 348  : 	            __except( EXCEPTION_EXECUTE_HANDLER )  

  006a2	b8 01 00 00 00	 mov	 eax, 1
$LN28@DispatchIo:
$LN35@DispatchIo:
  006a7	c3		 ret	 0
$LN27@DispatchIo:
  006a8	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 349  :                 {   					
; 350  :                 }

  006ab	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
$LN9@DispatchIo:

; 351  : 			}	
; 352  : 						
; 353  :             break;

  006b2	e9 94 00 00 00	 jmp	 $LN17@DispatchIo
$LN5@DispatchIo:

; 354  : 	    }
; 355  : 		
; 356  : 		case IOCTL_OPEN_PROCESS:
; 357  : 		{			
; 358  : 			if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(TOpenProcessCallbackInfo)) 

  006b7	8b 45 e4	 mov	 eax, DWORD PTR _IrpStack$[ebp]
  006ba	83 78 04 04	 cmp	 DWORD PTR [eax+4], 4
  006be	0f 82 87 00 00
	00		 jb	 $LN17@DispatchIo

; 359  : 			{
; 360  : 			    TOpenProcessInfo OpenProcessInfo = *(POpenProcessInfo)Irp->AssociatedIrp.SystemBuffer; 

  006c4	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  006c7	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  006ca	8b 02		 mov	 eax, DWORD PTR [edx]
  006cc	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  006cf	89 45 cc	 mov	 DWORD PTR _OpenProcessInfo$30062[ebp], eax
  006d2	89 4d d0	 mov	 DWORD PTR _OpenProcessInfo$30062[ebp+4], ecx

; 361  :                 HANDLE ProcessHandle = NULL;

  006d5	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _ProcessHandle$30064[ebp], 0

; 362  : 		        POpenProcessCallbackInfo OpenProcessCallbackInfo = NULL;

  006dc	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _OpenProcessCallbackInfo$30066[ebp], 0

; 363  : 			
; 364  : 			    __try

  006e3	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 2

; 365  : 				{
; 366  : 				    Status = OpenProcess(OpenProcessInfo.ProcessId, OpenProcessInfo.DesiredAccess, &ProcessHandle);

  006ea	8d 55 c8	 lea	 edx, DWORD PTR _ProcessHandle$30064[ebp]
  006ed	52		 push	 edx
  006ee	8b 45 d0	 mov	 eax, DWORD PTR _OpenProcessInfo$30062[ebp+4]
  006f1	50		 push	 eax
  006f2	8b 4d cc	 mov	 ecx, DWORD PTR _OpenProcessInfo$30062[ebp]
  006f5	51		 push	 ecx
  006f6	e8 00 00 00 00	 call	 _OpenProcess@12
  006fb	89 45 e0	 mov	 DWORD PTR _Status$[ebp], eax

; 367  : 			        if (Status == STATUS_SUCCESS)

  006fe	83 7d e0 00	 cmp	 DWORD PTR _Status$[ebp], 0
  00702	75 2e		 jne	 SHORT $LN3@DispatchIo

; 368  : 				    {
; 369  :                         OpenProcessCallbackInfo->ProcessHandle = ProcessHandle;

  00704	8b 55 c4	 mov	 edx, DWORD PTR _OpenProcessCallbackInfo$30066[ebp]
  00707	8b 45 c8	 mov	 eax, DWORD PTR _ProcessHandle$30064[ebp]
  0070a	89 02		 mov	 DWORD PTR [edx], eax

; 370  : 						
; 371  : 						memcpy(Irp->AssociatedIrp.SystemBuffer, OpenProcessCallbackInfo, IrpStack->Parameters.DeviceIoControl.OutputBufferLength);

  0070c	8b 4d e4	 mov	 ecx, DWORD PTR _IrpStack$[ebp]
  0070f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00712	52		 push	 edx
  00713	8b 45 c4	 mov	 eax, DWORD PTR _OpenProcessCallbackInfo$30066[ebp]
  00716	50		 push	 eax
  00717	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0071a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0071d	52		 push	 edx
  0071e	e8 00 00 00 00	 call	 _memcpy
  00723	83 c4 0c	 add	 esp, 12			; 0000000cH

; 372  :                         Irp->IoStatus.Information = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

  00726	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00729	8b 4d e4	 mov	 ecx, DWORD PTR _IrpStack$[ebp]
  0072c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0072f	89 50 1c	 mov	 DWORD PTR [eax+28], edx
$LN3@DispatchIo:

; 373  : 				    }		        
; 374  : 				}

  00732	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
  00739	eb 10		 jmp	 SHORT $LN17@DispatchIo
$LN30@DispatchIo:
$LN39@DispatchIo:

; 375  : 	            __except( EXCEPTION_EXECUTE_HANDLER )  

  0073b	b8 01 00 00 00	 mov	 eax, 1
$LN32@DispatchIo:
$LN36@DispatchIo:
  00740	c3		 ret	 0
$LN31@DispatchIo:
  00741	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 376  :                 {   					
; 377  :                 }

  00744	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1
$LN17@DispatchIo:

; 378  : 			}	
; 379  : 								
; 380  :             break;
; 381  : 		}
; 382  : 							
; 383  :         default: break;
; 384  :     }
; 385  : 
; 386  :     Irp->IoStatus.Status = Status;

  0074b	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  0074e	8b 4d e0	 mov	 ecx, DWORD PTR _Status$[ebp]
  00751	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 387  :     IoCompleteRequest(Irp, IO_NO_INCREMENT);

  00754	32 d2		 xor	 dl, dl
  00756	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00759	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 388  : 		
; 389  :     return Status;

  0075f	8b 45 e0	 mov	 eax, DWORD PTR _Status$[ebp]
$LN21@DispatchIo:

; 390  : }

  00762	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00765	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0076c	5f		 pop	 edi
  0076d	5e		 pop	 esi
  0076e	5b		 pop	 ebx
  0076f	8b e5		 mov	 esp, ebp
  00771	5d		 pop	 ebp
  00772	c2 08 00	 ret	 8
_DispatchIoCtl@8 ENDP
_TEXT	ENDS
PUBLIC	_DriverEntry@8
; Function compile flags: /Odtp
_TEXT	SEGMENT
_DriverName$ = -24					; size = 8
_DeviceName$ = -16					; size = 8
_Status$ = -8						; size = 4
_DeviceObject$ = -4					; size = 4
_DriverObject$ = 8					; size = 4
_RegistryPath$ = 12					; size = 4
_DriverEntry@8 PROC

; 227  : {

  00780	55		 push	 ebp
  00781	8b ec		 mov	 ebp, esp
  00783	83 ec 18	 sub	 esp, 24			; 00000018H

; 228  :     NTSTATUS           Status;
; 229  :     UNICODE_STRING     DriverName;
; 230  :     UNICODE_STRING     DeviceName;
; 231  :     PDEVICE_OBJECT     DeviceObject;
; 232  : 
; 233  :     RtlInitUnicodeString(&DriverName, L"\\Device\\NSHIELD");

  00786	68 00 00 00 00	 push	 OFFSET ??_C@_1CA@HCBGJDP@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAN?$AAS?$AAH?$AAI?$AAE?$AAL?$AAD?$AA?$AA@
  0078b	8d 45 e8	 lea	 eax, DWORD PTR _DriverName$[ebp]
  0078e	50		 push	 eax
  0078f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 234  :     Status = IoCreateDevice(DriverObject, 0, &DriverName, FILE_DEVICE_UNKNOWN, 0, TRUE, &DeviceObject);

  00795	8d 4d fc	 lea	 ecx, DWORD PTR _DeviceObject$[ebp]
  00798	51		 push	 ecx
  00799	6a 01		 push	 1
  0079b	6a 00		 push	 0
  0079d	6a 22		 push	 34			; 00000022H
  0079f	8d 55 e8	 lea	 edx, DWORD PTR _DriverName$[ebp]
  007a2	52		 push	 edx
  007a3	6a 00		 push	 0
  007a5	8b 45 08	 mov	 eax, DWORD PTR _DriverObject$[ebp]
  007a8	50		 push	 eax
  007a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateDevice@28
  007af	89 45 f8	 mov	 DWORD PTR _Status$[ebp], eax

; 235  : 	
; 236  :     if(Status != STATUS_SUCCESS)

  007b2	83 7d f8 00	 cmp	 DWORD PTR _Status$[ebp], 0
  007b6	74 08		 je	 SHORT $LN2@DriverEntr

; 237  :       return Status;

  007b8	8b 45 f8	 mov	 eax, DWORD PTR _Status$[ebp]
  007bb	e9 86 00 00 00	 jmp	 $LN3@DriverEntr
$LN2@DriverEntr:

; 238  : 	  	  
; 239  :     RtlInitUnicodeString(&DeviceName, L"\\DosDevices\\NSHIELD"); 

  007c0	68 00 00 00 00	 push	 OFFSET ??_C@_1CI@LPCKBFKB@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAN?$AAS?$AAH?$AAI?$AAE?$AAL?$AAD?$AA?$AA@
  007c5	8d 4d f0	 lea	 ecx, DWORD PTR _DeviceName$[ebp]
  007c8	51		 push	 ecx
  007c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 240  :     Status = IoCreateSymbolicLink(&DeviceName, &DriverName);

  007cf	8d 55 e8	 lea	 edx, DWORD PTR _DriverName$[ebp]
  007d2	52		 push	 edx
  007d3	8d 45 f0	 lea	 eax, DWORD PTR _DeviceName$[ebp]
  007d6	50		 push	 eax
  007d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateSymbolicLink@8
  007dd	89 45 f8	 mov	 DWORD PTR _Status$[ebp], eax

; 241  : 
; 242  :     if(Status != STATUS_SUCCESS)

  007e0	83 7d f8 00	 cmp	 DWORD PTR _Status$[ebp], 0
  007e4	74 0f		 je	 SHORT $LN1@DriverEntr

; 243  :     {
; 244  :         IoDeleteDevice(DeviceObject);

  007e6	8b 4d fc	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  007e9	51		 push	 ecx
  007ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4

; 245  :         return Status;

  007f0	8b 45 f8	 mov	 eax, DWORD PTR _Status$[ebp]
  007f3	eb 51		 jmp	 SHORT $LN3@DriverEntr
$LN1@DriverEntr:

; 246  :     }
; 247  : 	
; 248  :     DriverObject->DriverUnload                         = UnloadDriver;

  007f5	8b 55 08	 mov	 edx, DWORD PTR _DriverObject$[ebp]
  007f8	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], OFFSET _UnloadDriver@4

; 249  :     DriverObject->MajorFunction[IRP_MJ_CREATE]         = DispatchCreate;

  007ff	8b 45 08	 mov	 eax, DWORD PTR _DriverObject$[ebp]
  00802	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], OFFSET _DispatchCreate@8

; 250  :     DriverObject->MajorFunction[IRP_MJ_CLOSE]          = DispatchClose;

  00809	8b 4d 08	 mov	 ecx, DWORD PTR _DriverObject$[ebp]
  0080c	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], OFFSET _DispatchClose@8

; 251  :     DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchIoCtl;

  00813	8b 55 08	 mov	 edx, DWORD PTR _DriverObject$[ebp]
  00816	c7 42 70 00 00
	00 00		 mov	 DWORD PTR [edx+112], OFFSET _DispatchIoCtl@8

; 252  : 		
; 253  : 	ProcessMonitorCallbackInfo = ExAllocatePoolWithTag(NonPagedPool, sizeof(TProcessMonitorCallbackInfo), 'TgPM');

  0081d	68 4d 50 67 54	 push	 1416056909		; 5467504dH
  00822	68 08 02 00 00	 push	 520			; 00000208H
  00827	6a 00		 push	 0
  00829	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0082f	a3 00 00 00 00	 mov	 DWORD PTR _ProcessMonitorCallbackInfo, eax

; 254  : 	
; 255  : 	ZwQueryInformationProcess = GetSystemRoutineAddress(L"ZwQueryInformationProcess");

  00834	68 00 00 00 00	 push	 OFFSET ??_C@_1DE@MLPIADGK@?$AAZ?$AAw?$AAQ?$AAu?$AAe?$AAr?$AAy?$AAI?$AAn?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AAi?$AAo?$AAn?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$AA@
  00839	e8 00 00 00 00	 call	 _GetSystemRoutineAddress@4
  0083e	a3 00 00 00 00	 mov	 DWORD PTR _ZwQueryInformationProcess, eax

; 256  : 
; 257  :     return Status;

  00843	8b 45 f8	 mov	 eax, DWORD PTR _Status$[ebp]
$LN3@DriverEntr:

; 258  : }

  00846	8b e5		 mov	 esp, ebp
  00848	5d		 pop	 ebp
  00849	c2 08 00	 ret	 8
_DriverEntry@8 ENDP
_TEXT	ENDS
END
